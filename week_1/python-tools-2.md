# **Poetry Tool**

- Manages project dependencies and turns a project into a shareable package  
- Helps manage the Python environment  
- Uses one config file (`pyproject.toml`) and a lock file (`poetry.lock`)  

**With Poetry:**

- Uses `pyproject.toml` and `poetry.lock`  
- Contains version, metadata, and dependencies (with virtualenv)  

---

## **Features**

- Version locking  
- Virtual environment handling (automatically creates & uses virtualenv)  
- Separate dependencies for development and runtime  
- No manual project folder setup  
- Commands to build the project into a package  

---

## **.toml File**

- **.toml** = Tom’s Obvious, Minimal Language (human-readable config format)  
- **pyproject.toml** → metadata, build requirements, tool-specific configs  

---

## **Basic Poetry Commands**

- Setup existing project:  
```bash
poetry init
````

* Create new project skeleton:

```bash
poetry new projectName
```

* Add runtime dependency:

```bash
poetry add pkg-name
```

* Add development-only dependency:

```bash
poetry add --dev pkg-name
```

* Run commands from outside poetry environment:

```bash
poetry run <command>
```

---

## **Why Poetry?**

* Unified configuration
* Virtual environments
* Dependency resolver
* Easy to publish
* Version locking

---

## **Installing Poetry**

* Using pipx:

```bash
pipx install poetry
```

* Using official installer:

```bash
curl -sSL https://install.python-poetry.org/ | python3 -
```

* `-s` → silent mode

* `-S` → show errors

* `-L` → follow redirects

* Pipelined to python3 to execute curl output

* Update Poetry: run the same command again

---

## **Adding Dependencies**

* From GitHub (latest version, replaces current):

```bash
poetry add packageName --git <link>
```

* From specific branch:

```bash
poetry add packageName --git <repo> --branch <branchName>
```

* From tag:

```bash
poetry add packageName --git <repo> --tag <tagName>
```

* From commit:

```bash
poetry add packageName --git <repo> --rev <hash-code>
```

* From local path:

```bash
poetry add packageName --path <path-to-package>
```

* Use `--develop` for editable installations
* From PyPI:

```bash
poetry add package-name
```

---

## **Poetry.lock**

* Lock file generated by Poetry
* Ensures deterministic installs by locking exact versions

**Commands:**

* Create lock file:

```bash
poetry lock
```

* Install dependencies:

```bash
poetry install
```

* By default installs from `poetry.lock`
* If lock missing → installs current project environment
* Install dependencies only (not project):

```bash
poetry install --no-root
```

* Update dependency versions:

```bash
poetry update
```

* Add latest version of a package:

```bash
poetry add package-name@latest
```

* View configs:

```bash
poetry config --list
```

* Modify config:

```bash
poetry config <key> <value>
```

* Uninstall Poetry: manual uninstall

---

## **Newer Tool Similar to Poetry**

* Hatch

---

# **Formatting Tools**

## **Black**

* Python code formatter
* Automatically formats code for indentation, line length, spacing

**Commands:**

* Format all code:

```bash
black .
```

* Check formatting:

```bash
black --check filename
```

---

## **Isort**

* Organizes imports in Python files
* Separates standard library, third-party, and local libraries

**Commands:**

* Sort all imports:

```bash
isort .
```

* Check imports:

```bash
isort filename --check-only --profile black
```

* `--check-only` → checks without changing
* `--profile black` → compatible with Black formatter

**Sort Order:**

1. Standard library imports
2. Third-party imports
3. Local application imports

* Install tools:

```bash
pip install black isort
```

---

## **Check for Unused/Unwanted Imports**

* Use flake8:

```bash
flake8 filename --select=F401
```

---

# **Mypy (Static Type Checker)**

* Parses code + type hints, checks consistency
* Catches bugs before runtime (compile-time checking)

**Typing:**

* Static typing → declare variable, parameter, return types
* Dynamic typing → types determined at runtime (Python, JS)

**Note:** mypy usually skips dynamic typing

**Options:**

* `--disallow-untyped-defs` → disallow functions without type hints
* `--check-untyped-defs` → allow untyped functions but check them

**Skipping / Ignoring Errors:**

* Add `# type: ignore` near line
* Add `# type: ignore` at top of file
* Exclude via config file

---

## **mypy.ini - Configuration File**

* Set rules globally instead of using flags

```ini
[mypy]
exclude = (test/ | migration/ | ignore.py)  # exclude test, migration folders & ignore.py

[mypy-tests.*]
ignore_errors = true
```
